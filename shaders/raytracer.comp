#version 460

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image2D FinalImage;

#define MAX_SPHERES 32

struct SphereInfo
{
   vec3 Center;
   float Radius;
};
uniform SphereInfo Sphere[MAX_SPHERES];

uniform int SphereNum;
uniform int FrameIndex;

const float zero = 0.0f;
const float one = 1.0f;

uint wangHash(inout uint seed)
{
	seed = (seed ^ 61u) ^ (seed >> 16u);
	seed *= 9u;
	seed = seed ^ (seed >> 4u);
	seed *= 0x27d4eb2du;
	seed = seed ^ (seed >> 15u);
	return seed;
}

float getRandomFloat(inout uint state)
{
	return float(wangHash( state )) * (1.0f / 4294967296.0f);
}

vec3 getRandomPointInUnitSphere(inout uint seed)
{
   vec3 point = vec3(getRandomFloat( seed ), getRandomFloat( seed ), getRandomFloat( seed ));
   point = point * vec3(2.0f, 6.28318530718f, one) - vec3(one, zero, zero);
   float phi = point.y;
   float r = pow( point.z, one / 3.0f );
   return r * vec3(sqrt( one - point.x * point.x ) * vec2(sin( phi ), cos( phi )), point.x);
}

bool hitSphere(
   inout float t,
   inout vec3 position,
   inout vec3 normal,
   in vec3 ray_origin,
   in vec3 ray_direction,
   in float t_min,
   in float t_max,
   in int index
)
{
   vec3 oc = ray_origin - Sphere[index].Center;
   float a = dot( ray_direction, ray_direction );
   float b = dot( oc, ray_direction );
   float c = dot( oc, oc ) - Sphere[index].Radius * Sphere[index].Radius;
   float discriminant = b * b - a * c;
   if (discriminant >= zero) {
      t = (-b - sqrt( discriminant )) / a;
      if (t_min < t && t < t_max) {
         position = ray_origin + t * ray_direction;
         normal = (position - Sphere[index].Center) / Sphere[index].Radius;
         return true;
      }

      t = (-b + sqrt( discriminant )) / a;
      if (t_min < t && t < t_max) {
         position = ray_origin + t * ray_direction;
         normal = (position - Sphere[index].Center) / Sphere[index].Radius;
         return true;
      }
   }
   return false;
}

bool hit(
   inout float t,
   inout vec3 position,
   inout vec3 normal,
   in vec3 ray_origin,
   in vec3 ray_direction,
   in float t_min,
   in float t_max
)
{
   bool hit_anything = false;
   float closest_so_far = t_max;
   for (int i = 0; i < SphereNum; ++i) {
      if (hitSphere( t, position, normal, ray_origin, ray_direction, t_min, closest_so_far, i )) {
         hit_anything = true;
         closest_so_far = t;
      }
   }
   return hit_anything;
}

vec3 getColor(inout bool need_to_reflect, inout vec3 ray_origin, inout vec3 ray_direction, inout uint seed)
{
   float t;
   vec3 position, normal;
   if (hit( t, position, normal, ray_origin, ray_direction, zero, 1E+7f )) {
      ray_origin = position;
      ray_direction = normal + getRandomPointInUnitSphere( seed );
      need_to_reflect = true;
      //return 0.5f * getColor( need_to_reflect, ray_origin, ray_direction, seed );
      //return 0.5f * (normal + vec3(one));
      return vec3(0.5f);
   }
   else {
      need_to_reflect = false;
      vec3 direction = normalize( ray_direction );
      t = 0.5f * direction.y + 0.5f;
      return mix( vec3(one), vec3(0.5f, 0.7f, one), t );
   }
}

void main()
{
   int x = int(gl_GlobalInvocationID.x);
   int y = int(gl_GlobalInvocationID.y);
   ivec2 image_size = imageSize( FinalImage );
   if (x >= image_size.x || y >= image_size.y) return;

   const vec3 bottom_left_corner = vec3(-2.0f, -one, -one);
   const vec3 horizontal = vec3(4.0f, zero, zero);
   const vec3 vertical = vec3(zero, 2.0f, zero);

   const int sample_num = 3;
   vec3 color = vec3(zero);
   vec3 ray_origin = vec3(zero, zero, zero);
   vec3 ray_direction;
   uint seed = (gl_GlobalInvocationID.x * 1973u + gl_GlobalInvocationID.y * 9277u + uint(FrameIndex) * 26699u) | 1u;
   for (int i = 0; i < sample_num; ++i) {
      float u = (float(x) + getRandomFloat( seed )) / float(image_size.x);
      float v = (float(y) + getRandomFloat( seed )) / float(image_size.y);
      ray_direction = bottom_left_corner + u * horizontal + v * vertical;

      bool need_to_reflect = true;
      vec3 partial_color = vec3(one);
      while (need_to_reflect) {
         partial_color = partial_color * getColor( need_to_reflect, ray_origin, ray_direction, seed );
      }
      color += partial_color;
   }
   color /= float(sample_num);
   color = sqrt( color );
   imageStore( FinalImage, ivec2(x, y), vec4(color, one) );
}